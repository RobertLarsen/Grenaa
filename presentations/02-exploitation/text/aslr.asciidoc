Address Space Layout Randomization
----------------------------------

Fra Wikipedia:

"Address space layout randomization (ASLR) is a computer security technique involved in protection from buffer overflow attacks. In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries."

Address Space Layout Randomization
----------------------------------

[source,bash]
------------------------------------------------
$ cat t.c
#include <stdio.h>
#include <malloc.h>
int main(int argc, char *argv[]) {
    printf("%p %p %p\n", &argc, malloc(10), main);
    return 0;
}
$ gcc -m32 -o t t.c
------------------------------------------------

Address Space Layout Randomization
----------------------------------

[source,bash]
------------------------------------------------
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space                                                                      
0
$ ./t && ./t && ./t
0xffffce30 0x804b008 0x804844d
0xffffce30 0x804b008 0x804844d
0xffffce30 0x804b008 0x804844d
------------------------------------------------

Address Space Layout Randomization
----------------------------------

[source,bash]
------------------------------------------------
$ echo 1 | sudo tee /proc/sys/kernel/randomize_va_space
1
$ ./t && ./t && ./t
0xffd8e120 0x804b008 0x804844d
0xffe1d070 0x804b008 0x804844d
0xff8b1a60 0x804b008 0x804844d
------------------------------------------------

Address Space Layout Randomization
----------------------------------

[source,bash]
------------------------------------------------
$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space                                                                      
2
$ ./t && ./t && ./t
0xffc806f0 0x8e63008 0x804844d
0xffc5dbb0 0x985b008 0x804844d
0xffb62320 0x94bb008 0x804844d
------------------------------------------------

Address Space Layout Randomization
----------------------------------

[source,bash]
------------------------------------------------
$ checksec t
[*] '/media/code/Grenaa/presentations/02-exploitation/t'
    Arch:          i386-32-little
    RELRO:         Partial RELRO
    Stack Canary:  No canary found
    NX:            NX enabled
    PIE:           No PIE
------------------------------------------------

Address Space Layout Randomization
----------------------------------

[source,bash]
------------------------------------------------
$ gcc -m32 -fpic -pie -o t t.c                                                                                               
$ checksec t
[*] '/media/code/Grenaa/presentations/02-exploitation/t'
    Arch:          i386-32-little
    RELRO:         Partial RELRO
    Stack Canary:  No canary found
    NX:            NX enabled
    PIE:           PIE enabled
$ ./t && ./t && ./t
0xffef8ac0 0xf96f9008 0xf778863b
0xff868d30 0xf7e6e008 0xf775f63b
0xffa5f1d0 0xf81c8008 0xf772663b
------------------------------------------------

Address Space Layout Randomization
----------------------------------

Statistik fra 100.000 samplinger afslører at 32 bit binaries randomizer således:

[frame="topbot",options="header"]
|============================================================
| Område | ASLR bitmask | Tilfældige bits | Antal muligheder
| Stak   | '0x00fffff0' |       20        |    1.048.576
| Heap   | '0x0ffff000' |       16        |       65.536
| PIE    | '0x003ff000' |       10        |        1.024
|============================================================

For de interesserede er her samme data for 64 bit binaries:

[frame="topbot",options="header"]
|====================================================================
| Område |     ASLR bitmask     | Tilfældige bits | Antal muligheder
| Stak   | '0x00000003fffffff0' |      30         | 1.073.741.824
| Heap   | '0x000001fffffff000' |      29         |   536.870.912
| PIE    | '0x000001fffffff000' |      29         |   536.870.912
|====================================================================

TIP: ASLR bliver "genereret" under 'execve'. Intet bliver ændret efter en 'fork', så forbinder du to gange til en forkende server, vil hukommelseslayoutet være éns for begge forbindelser.

Overvind ASLR
-------------

* Leak hukommelse
* Brug ikke randomiserede områder. Non PIE executables f.eks.
* Brug en NOP slæde
* Brute force til en vis grænse
* 'ulimit -s unlimited' (32 bit local exploits)

NOP slæde
---------

NOP (NO Procedure) er en instruktion som intet gør.

Hvis man ikke kender den præcise adresse på sin shellcode men kan komme nogenlunde tæt på, kan man ligge en stribe NOP instruktioner foran.

Måske kender man ikke de mindst betydende 10 bits, hvilket giver en usikkerhed på 1024 bytes. Ligger man 1024 NOP instruktioner foran sin shellcode skal man altså bare ramme én af disse adresser, og så "glider" man ned til shellcoden.

[source,python]
------------------------------------------------
shellcode = asm(shellcraft.nop() * 1024 + shellcraft.findpeersh())
------------------------------------------------

Trampolin
---------

Hvis 'EAX' peger på en buffer, som vi har placeret shellcode i, kan vi returnere til en 'jmp eax' eller 'call eax' instruktion. En sådan instruktion kaldes for en trampolin.

Sådanne instruktioner kan findes med 'ROPgadget' (et meget kraftfulgt værktøj!):

[source,bash]
------------------------------------------------
$ gcc -m32 -o t t.c
$ ROPgadget --binary t|grep -E ': ((jmp)|(call)) eax'
0x080483b6 : call eax
------------------------------------------------

Tredje opgave
-------------

Magen til anden opgave men med ASLR. Lytter på 'localhost:10003'.

[source,bash]
------------------------------------------------
$ ps aux | grep assignment | grep 10003 | awk '{print $2}'
3712
------------------------------------------------

Åben i gdb med:

[source,bash]
------------------------------------------------
$ sudo gdb ./integer_conversion 3712
------------------------------------------------

Problemer med PIE
-----------------
Under udviklingen af et exploit vil vi gerne

* sætte et breakpoint i slutningen af en funktion
* benytte en trampolin
* noget tredje som kræver at vi kender en adresse

Problemer med PIE
-----------------
Først find funktionens/trampolinens offset:
[source,bash]
------------------------------------------------
$ readelf -s integer_conversion_canary_pie | grep handle_client
    49: 0000099b   156 FUNC    GLOBAL DEFAULT   13 handle_client
$ ROPgadget --binary integer_conversion_canary_pie | grep -E ': ((jmp)|(call)) esp'
0x00000db4 : call esp
------------------------------------------------

Problemer med PIE
-----------------
Find processens ID:
[source,bash]
------------------------------------------------
$ ps aux|grep integer_conversion_canary_pie|grep -v grep|awk '{print $2}'
24128
------------------------------------------------

Problemer med PIE
-----------------
Find så ud af, hvor filen er mappet:
[source,bash]
------------------------------------------------
$ grep integer_conversion_canary_pie /proc/24128/maps
f7712000-f7714000 r-xp 00000000 00:1a 305   integer_conversion_canary_pie
f7714000-f7715000 r-xp 00001000 00:1a 305   integer_conversion_canary_pie
f7715000-f7716000 rwxp 00002000 00:1a 305   integer_conversion_canary_pie
------------------------------------------------

Problemer med PIE
-----------------
[source,bash]
------------------------------------------------
$ readelf -s integer_conversion_canary_pie | grep handle_client
    49: 0000099b   156 FUNC    GLOBAL DEFAULT   13 handle_client
------------------------------------------------
'0xf7712000' + '0x99b' = '0xf771299b'

[source,bash]
------------------------------------------------
$ ROPgadget --binary integer_conversion_canary_pie | grep -E ': ((jmp)|(call)) esp'
0x00000db4 : call esp
------------------------------------------------
'0xf7712000' + '0xdb4' = '0xf7712db4'

Problemer med PIE
-----------------
Husk at i en PIE bliver disse bits tilfældigt udvalgt, når processen eksekveres: '0x003ff000'
